\section{Introduction}
Security and data privacy are critical aspects of most software programmes. The
need for such security can derive from the need for compliance with government
regulations, and individual and company privacy requirements. The protection of
sensitive information and industry data is also vital for software to stay
competitive. The ability of ‘hackers’ to extract sensitive data is continuously
advancing, and so software data protection must also continuously evolve, in
order to keep ahead of such efforts.
\par
One of the mechanisms that could be implemented in the future to protect data is
obfuscation. Software obfuscation aims at making computer programs unintelligible
for a human being, without affecting the functionality of the software. Although
software must be delivered into the hands of the public in order for the public
to make use of the software, obfuscation hides the information contained within
the software, including the code itself, by rendering it illegible to a user or
hacker.
\par
Obfuscation has potential useful applications in preventing reverse engineering
and thereby protecting Intellectual Property, and in enabling secure software
distribution. Obfuscation can also be a powerful means of encrypting data.
\par
Until recently, there was no formal definition of obfuscation, and all techniques,
including manually obscuring data, could be given the label “obfuscation”. These
techniques do not have quantifiable security and anyone with a debugger, a compiler
a day's worth of effort can reverse engineer code that has been obfucated with the
current best efforts\cite{Hsieh}.
\par
Recent developments in cryptography theory have however produced a formal definition of
obfuscation, which will most assuredly lead to an increased interest in the field,
in the hope that obfuscation can be practically applied to protect software in the
near future. The theory also suggests that the adversray work factor, \.i.e. the
work required to be performed by an adversary to break the obsucation, scales exponentially
with the program runtime.\cite{Hsieh}
\par
However, the drawback of using obfuscation is that it may be ultimately limited
by the hardware on which the software is run. Obfuscators need to produce obfuscated
programs using available computing resources in a commercially relevant amount of
time. These obfuscations then need to be evaluated by end users in relatively
similar, if not more challenging conditions, in terms of hardware performance
and functionality. Normal encryption methods in general have small variable size
and a low number of instructions, and therefore require little run time to execute.
Obfuscators however are technically challenging to implement, and the number of
variables and instructions arising from an obfuscation may surpass the limits of
the hardware within which the software is run.
\par
This paper aims to test the hypothesis that obfuscation is limited by the hardware
it runs on. Should this hypothesis prove true, it would place serious constraints
on the practicality of obfuscation in most situations.
