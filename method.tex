\section{Methodology}
We now describe the algorithm used to simulated an obfuscated boolean circuit and the tools used to measure its evaluation impact on a hardware platform.

\subsection{BPW Generation} 
Thomborson proposed a space-efficient and computationally-appropriate file format (BPW) for the evaluation of very large Boolean functions with bounded program widths\cite{clark}. Gates of a circuit are represented by descriptors holding information about their type (AND, OR, $\dots$) and are sequentially encoded inside the file's body. In our experiment we generate random boolean circuits (which evaluates a random boolean function) with varying width $w = \{ 10^3, 10^4, 10^5, 10^6, 10^7, 10^8\}$ for a fixed circuit size $N = 10^8$. The relationship between a circuit width and depth is $ N = w \times D $, so for $ w = N$ the circuit has depth 1.
\par
The generated circuits are represented using a simplified BPW format by storing the gate type and the input indices only and by making some assumptions about the properties of the circuit under test. In particular, we make the following assumptions about the size of the circuit's inputs and outputs as well as the manner outputs from level $L_i$ are passed to gates in level $L_{i+1}$ as inputs.
\begin{enumerate}  
\item All circuits have size $N = 10^8$
\item A circuit input array has size $w$.
\item Any given level $L$ has exactly $w$ gates.
\item Every gate has only one output.
\item A circuit output array has size $w$.
\item Any given gate from a level $L_i$ has between one and three inputs that come from level $L_{i-1}$ exclusively, such that:\break $G_i = f(X)$, where $f$ is a boolean operator and $X$ is an 8-byte array of size 1, 2 or 3. 
\item The output of a gate is written inside the output array at the same index of the gate. $G_i(X) = Output$ $array[i]$.
\end{enumerate}
The \textit{rand()} method from the \textit{C} standard library was used to attribute a random type to a gate, as well as assign its input indices.

\subsection{Evaluation}
A circuit evaluation is sequential at both gate and layer level. During execution, gates of a level $L_i$ are processed in ascending order of index in the level. Inputs indices for a gate are randomly distributed over $[0, w−1]$. Every gate retrieves its relevant inputs as described by the gate descriptor. Once a gate is processed, its output is stored in the output array at the same index as the gate. Once all the gates of level $L_i$ are processed, the execution cursor moves to level $L_{i+1}$. The random distribution of gate input indices will significantly affect the overall performance of the circuit for large $w$, as the entire input array cannot fit in the cache. Figure \ref{fig:level} describes how a level is evaluated.
\begin{figure}[h]
	\center
	\includegraphics[width=0.8\textwidth]{img/level.png}
	\caption{Simple description of Level $L_i$ evaluation}
	\label{fig:level}
\end{figure}
\par
\subsection{Hardware}
Obfuscators might occasionally run on super computers, however we believe viable commercial use for obsfuscators would require them to run on mass maket platfroms such as smartphones, battery powerd laptops and desktop computers\cite{clark}. The target platorm for the circuits evaluation is a high-range desktop computer. The CPU is a 64-bits-instruction-set Intel(R) Core(TM) i5-3570K with a base frequency of 3.40 GHz (Max of 4.1GHz). It has 4 cores that can run a thread each and has the following cache capacities (in bytes): 
\begin{itemize}[noitemsep]
\item Level 1 data cache: 32K
\item Level 1 instruction cache: 32K
\item Level 2 cache: 256K
\item Level 3 cache: 6144K
\end{itemize}
We predict that having a circuit with a width higher than the capacity of the last-level cache is a perfect candidate to observe an impact on performance.
\par
The operating system is Linux Fedora 22 on kernel 4.4.5.


\subsection{Metrics}
The \textit{perf} linux command was used to measure the impact of evaluating a circuit on the CPU. \textit{perf} is a tool written in \text{C} that uses Performance Counters to profile an application\footnote{\url{https://github.com/torvalds/linux/tree/master/tools/perf}}. Performance counters are CPU hardware registers that count hardware events such as instructions executed, cache-misses suffered, or branches mispredicted\cite{perf}. The \textit{perf} tool has the advantage of being program oriented, instead of system oriented \ref{}.   In particular, the \textit{perf stat} subcommand allows to retrieval event counts that are of interest to our experiment. These events are mainly \textit{instructions, cycles} and \textit{LLC-loads}. 
\begin{itemize}
\item \textbf{instructions}
\item \textbf{cycles}
\item \textbf{LLC-loads}
\end{itemize}
For every value of $w$, we configure \textit{perf} to run the experiment 3 times and collect the arithmetic average counts.





\section{Simulation Results}
In this section we present the results of our experiement.
\par
We suggest that the total running time of a circuit follows the analytical model:
\begin{equation}
T = \max\{ t_g + t_e, t_m(w) \}
\end{equation}
where $T$ is the total elapsed (wallclock) time in processing a single gate, $t_g$ is the CPU time for generating a gate, $t_e$ is the CPU time for evaluating a gate, and $t_m(w)$ are the memory-stalls from the gate-generation and gate-evaluation computations.
\par
In our experiment, we generate the entire circuit prior to its evaluation. $t_g$ is in fact related to the time cost of loading of the gate for execution. We assume that this time component is near constant per gate and is not affected by the width $w$. The generation step executed initially is therefore not monitored for performance. The resulting circuit is stacked gate by gate in a simplified BPW file. Following the initial BPW format developed by Thonborson, the first 4 bytes represent the header of the a BPW file\cite{clark}. The following bytes then represent the total gates of the circuit. All gates are sequentially represented from index $0$ to index $10^8-1$. A given gate's encoding varies from 9 to 25 bytes. The first byte holds the type of the gate. The following 8 to 24 bytes present the input indices encoded over 64-bits each. The gate’s representation could be optimised to compress a gate’s representation but we chose to keep the existing model for simplicity. As mentioned earlier, the size of the circuits under test was fixed to $N = 10^8$. The average size of a circuit stored in a BPW file is therefore $avg(sizeof(Gate)) * 10^8 \approx 2 GB$ \footnote{We modelled 14 types of Gates; 1 $\times$ 1-input, 6 $\times$ 2-input and 7 $\times$ 3-input gates. On average, a gate has 2.43 inputs encoded with 8 bytes per input plus one byte for the gate type.}.

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
w                 & $10^3$       & $10^4$       & $10^5$       \\ \hline
task-clock (ms)   & 13116.554712 & 13322.905953 & 13313.335011 \\ \hline
instructions      & 99200423097  & 97602445259  & 97553743526  \\ \hline
cycles            & 55393862507  & 56255744084  & 56207517444  \\ \hline
instruction/cycle & 1.74         & 1.76         & 1.74         \\ \hline
branches          & 17179168771  & 16896966649  & 16887492840  \\ \hline
branch-misses     & 213275235    & 267635214    & 267596585    \\ \hline
LLC-loads         & 75319029     & 75177952     & 78311853     \\ \hline
std deviation     & 1.49\%       & 0.94\%       & 0.27\%       \\ \hline
\end{tabular}
\caption{Simulation results for $ w \in \{10^3, 10^4, 10^5\}$ }
\label{tab:res1}
\end{table}


\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
w                 & $10^6$      & $10^7$      & $10^8$       \\ \hline
task-clock (ms)   & 13633.97763 & 16041.15891 & 17507.07431  \\ \hline
instructions      & 97578653791 & 98201779911 & 103646369628 \\ \hline
cycles            & 57584456723 & 67736311966 & 73941409511  \\ \hline
instruction/cycle & 1.69        & 1.44        & 1.4          \\ \hline
branches          & 16897296695 & 17058902603 & 18501020880  \\ \hline
branch-misses     & 266970610   & 266910904   & 268274635    \\ \hline
LLC-loads         & 328139283   & 380853849   & 505923626    \\ \hline
std deviation     & 0.43\%      & 0.50\%      & 0.19\%       \\ \hline
\end{tabular}%
\caption{Simulation results for $ w \in \{10^6, 10^7, 10^8\}$}
\label{tab:res2}
\end{table}


\par
From the results collected in \ref{tab:res1} and \ref{tab:res2} we established the following:

\[ T =
  \begin{cases}
    t_g + t_e       & \quad \text{if } \log_{10}(w) < 7\\
    t_m(w) & \quad \text{if } \log_{10}(w) > 7\\
  \end{cases}
\]

We estimate that $t_m(w)$ for $w = 10^3$ is negligible. In our experiment $E(w = 10^6)$ the total run time is assumed to reflect load and execution operations only (with no width penalty) which establishes $t_g + t_e \approx 130\text{ ns}$.\footnote{ For $w = 10^3, N=10^8$, we have $N \times T = 13116 \text{ms} \implies T \approx 130 \text{ns}$ }. 
Since the CPU has a frequency of 3.40 GHz the load and execution of a gate require about 450 CPU cycles per gate\footnote{$130 \times 10^{-9} \times 3.4 \times 10^9 = 442$}, which is up to 2000 instruction per cycle (at 1.7 instructions per cycle) on a quad-core CPU assuming no stalls. For all tested $w < 10^7$ we observed a stable instruction per cycle rate at 1.7 ins/cycle with 0.2 instruction per cycle stalled.
\par
For $ w > 10^7$ the computation becomes memory-bound, allowing us to estimate $t_m(10^7) = 162$ nsec and $t_m(10^8) = 176$ nsec. Since we used 6 2-input gate types and 7 3-input gate types (out of 14 gate types), a gate evaluation will have about 2.5 memory-fetches on average to read its inputs. The gate evaluation process will also write the result in the output buffer which will cause additional memory writes. There will also be some memory-reads when reading the gate's type.
\par
Once the gate is unpacked in a top-level \textit{C} \textbf{struc} of 16 bytes (1 byte for the type, 8 bytes for the input pointer, before padding to the largest power of 2), with 2.5 input indices of 8 bytes each, a level needs $ (16 + 2.5 \times 8) \times w $ of memory to be fully represented, e.g.\ levels for $w = 10^7$ need 3.6 GB. This amout of memory cannot obviously reside in cache, and on 4 GB memory platforms there would certainly be page-faults requiring hard disk activity. We estimate that the level array can fit inside our system's 16GB RAM without disk faults. Our initial algorithm loads an entire level before feeding into the execution loop. We could improve this by evaluating a gate as soon as it is loaded.  
\par
We desigend the gate inputs to be spread randomly in an array of width $w$. For any large enough $w$, the CPU last level cache (LLC) will alawys miss when the input bit array cannot be fully contained. On our test platform, LLC is 6MB wide. Whenever $w > 10^7$, the input array occupies $8 \times 10^7$ bits, the miss rate should be 
